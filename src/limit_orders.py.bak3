import sys
import math
import structlog
from base_order import BaseOrder

logger = structlog.get_logger()


class LimitOrder(BaseOrder):

    def _validate_price(self, symbol: str, price: float) -> bool:
        """Validate if the price meets symbol's requirements."""
        try:
            info = self.client.futures_exchange_info()
            symbol_info = next(s for s in info['symbols'] if s['symbol'] == symbol)
            
            # Check against price filter
            price_filter = next(f for f in symbol_info['filters'] if f['filterType'] == 'PRICE_FILTER')
            min_price = float(price_filter['minPrice'])
            max_price = float(price_filter['maxPrice'])
            tick_size = float(price_filter['tickSize'])

            if not (min_price <= price <= max_price):
                logger.error("price_validation_failed_range",
                           min_price=min_price,
                           max_price=max_price,
                           given_price=price)
                return False

            # Round to the nearest tick size
            precision = int(round(-math.log10(tick_size)))
            rounded_price = round(price / tick_size) * tick_size
            rounded_price = float(f"%.{precision}f" % rounded_price)

            if rounded_price != price:
                logger.error("price_validation_failed_tick_size",
                           tick_size=tick_size,
                           given_price=price,
                           suggested_price=rounded_price)
                return False

            return True    def place_order(self, symbol: str, side: str, quantity: float, price: float = None):
        """
        Place a limit order

        Args:
            symbol: Trading pair symbol (e.g., 'BTCUSDT')
            side: Order side ('BUY' or 'SELL')
            quantity: Order quantity
            price: Limit price for the order (optional, will be calculated if not provided)
        """
        # Validate inputs
        if not self._validate_symbol(symbol):
            raise ValueError(f"Invalid symbol: {symbol}")

        if not self._validate_quantity(symbol, quantity):
            raise ValueError(f"Invalid quantity: {quantity}")

        # If price is not provided, calculate it based on current market price
        if price is None:
            logger.info("Price not provided, calculating optimal limit price...")
            prices = self.calculate_order_prices(symbol, side)
            price = prices['limit_price']
            logger.info(f"Calculated limit price: {price}")
        
        # Validate price
        if not self._validate_price(symbol, price):
            raise ValueError(f"Invalid price {price} for symbol {symbol}")

        order_params = {
            "symbol": symbol,
            "side": side,
            "type": "LIMIT",
            "timeInForce": "GTC",  # Good Till Cancel
            "quantity": quantity,
            "price": price
        }

        try:
            return self._execute_order(self.client.futures_create_order, **order_params)
        except Exception as e:
            logger.error(f"Failed to place limit order: {str(e)}")
            raise


def main():
    if len(sys.argv) < 4 or len(sys.argv) > 5:
        print("Usage: python limit_orders.py <symbol> <side> <quantity> [price]")
        print("Example (with price): python limit_orders.py BTCUSDT SELL 0.01 35000")
        print("Example (auto-price): python limit_orders.py BTCUSDT BUY 0.01")
        sys.exit(1)
        
    symbol = sys.argv[1].upper()
    side = sys.argv[2].upper()
    quantity = float(sys.argv[3])
    # Set price to None if not provided
    price = float(sys.argv[4]) if len(sys.argv) == 5 else None
    
    try:
        limit_order = LimitOrder()
        result = limit_order.place_order(symbol, side, quantity, price)
        print(f"Order placed successfully: {result}")
    except Exception as e:
        print(f"Error placing order: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()